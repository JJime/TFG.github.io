<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title></title>
	<meta charset="UTF-8">
	<meta http-equiv="Content-type" content="text/html; charset=UTF-8">
    <style type="text/css">
/*<![CDATA[*/
    :link { color: #0563C1 }
    :visited { color: #954F72 }
    p.cleanuphtml-5 {margin-bottom:8.0pt;line-height:80%}
    b.cleanuphtml-4 {font-style: italic}
    p.cleanuphtml-3 {font-weight: bold}
    p.cleanuphtml-2 {text-align: center}
    a.cleanuphtml-1 {font-weight: bold}
    /*]]>*/
    </style>

  <!-- Clean HTML generated by http://www.cleanuphtml.com/ -->
	<meta name="Generator" content="Cleanup HTML"></head>
  <body>

      <div id="help_firmware_format">
      <h1>Microcode in WepSIM</h1>

	      <p>
	      </p>
	      <p>
                The microcode is loaded through a text file you have three sections:
	      </p>
	      <p>
	        1.    List of microprograms
	      </p>
	      <p>
	        2.    Register naming
	      </p>
	      <p>
	        3.    Pseudo-instructions
	      </p>
	      <p>
                The microprograms list starts with the code of <b>fetch</b>.
                An example of basic fetch microprogram could be:
	      </p>
	      <ul>
	      <p>
	        begin <br>
	        { <br>
	                fetch:    (T2, C0=1), <br>
	                             (Ta, Td, R, BW=11, C1), <br>
	                             (M2, C2, T1, C3), <br>
	                             (A0, B=0, C=0000) <br>
	        }
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322900">Figure</a> <b>11</b> <b>Example of description for</b> <b>Fetch</b>
	      </p>
	      <p>
		Control signals located between the parentheses ( and ) correspond to the signals to activate in one clock cycle. Thus the fetch requires four clock cycles, the last corresponds to decoding (included within the fetch).
	      </p>
	      <p>
		Then, the rest of microprograms associated with each instruction follows. Each microprogram has this format:
	      </p>
	      <ul>
	      <p>
	        inst1 field1 field2 field3<br>
	        {<br>
	                    co=000000,<br>
	                    nwords=1,<br>
	                    field1=reg(25,21),<br>
	                    field2=reg(20,16),<br>
	                    field3=reg(15,11),<br>
	                    {<br>
	                           (Cop=1001, SelP=11, C7, T6, LC, SelA=10100, SelB=01111, SelC=10111,<br>
	                             A0=1, B=1, C=0)<br>
	                    }<br>
	        }<br>
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322901">Figure</a> <b>12</b> <b>Example of description format for an instruction</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
		Where the first line describes the command name (inst1) and the parameters that have (registers, immediate values, etc.). Then a block opens with keys to describe the instruction.
	      </p>
	      <p>
		The first field in the example shown (co) indicates the 6 bits that uniquely identifies the instruction. This is not entirely true for arithmetic and logical instructions since it is possible to share the same opcode and as the field value cop differentiate. An example of this case would be:
	      </p>
	      <ul>
	      <p>
	         
	      </p>
	      <p>
	        inst1 field1 field2 field3<br>
	        {<br>
	                    co=000000,<br>
	                    <b>cop=0000,</b><br>
	                    nwords=1,<br>
	                    field1=reg(25,21),<br>
	                    field2=reg(20,16),<br>
	                    field3=reg(15,11),<br>
	                    {<br>
	                           (Cop=1001, SelP=11, C7, T6, LC, SelA=10100, SelB=01111, SelC=10111,<br>
	                             A0=1, B=1, C=0)
	                    }<br>
	        }<br>
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322902">Figure</a> <b>13</b> <b>Detail in the description of an instruction: field cop</b>
	      </p>
	      <p>
	        <br />
		The following fields indicate for each of the parameters what type (registration, immediately or address) as well as the start and end bits (from 0 up to 31) where the value of that parameter is.
	      </p>
	      <p>
		The parameter type is indicated by:
	      </p>
<ul>
	      <li>
	        parameter1 = reg(last-bit, first-bit), <br> for a register.
	      </li>
	      <li>
	        parameter1 = inm(last-bit, first-bit), <br> for an immediate value.
	      </li>
	      <li>
	        parameter1 = address(last-bit, first-bit)rel, <br> for a relative (to PC register) address.
	      </li>
	      <li>
	        parameter1 = address(last-bit, first-bit)abs, <br> for an absolute address.
	      </li>
</ul>
	      <p>
		Then, a new block is open where the microprogram for the instruction is described. The signals of each cycle are in parentheses and such cycles are separated by commas. If there is only one cycle then it is not necessary the comma. Within the parentheses the signs and the corresponding value is indicated. A only-bit signal can be expressed just by the name of the signal (it means that its value is one). The value of the signal should indicate in binary, using as many bits as the signal has. Signals and their corresponding value are separated using a comma.
	      </p>
	      <p>
		Register naming requires the label to be used for each of the 32 registers of the register file. An example of this section is:<br />
	        <br />
	      </p>
	      <ul>
	      <p>
	        registers
	      </p>
	      <p>
	        { <br>
	                  0=($zero, $0), <br>
	                  1=($at, $1), <br>
	                  2=($v0, $2), <br>
	                  3=($v1, $3), <br>
	                  4=($a0, $4), <br>
	                  5=($a1, $5), <br>
	                  6=($a2, $6), <br>
	                  7=($a3, $7), <br>
	                  .  <br>
	                  .  <br>
	                  .  <br>
	                  24=($t8, $24), <br>
	                  25=($t9, $25), <br>
	                  26=($k0, $26), <br>
	                  27=($k1, $27), <br>
	                  28=($gp, $28), <br>
	                  29=($sp, $29) (stack_pointer), <br>
	                  30=($fp, $30), <br>
	                  31=($ra, $31)  <br>
	        }
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322903">Figure</a> <b>14</b> <b>Example of register naming</b>
	      </p>
	      <p>
	        <br />
		In the last example, the names used where the MIPS32 architecture names. In this example the register 29 labeled with $ sp has the attribute "(stack_pointer)" to indicate that will be used as a the stack pointer.
	      </p>
	      <p>
	         
	      </p>
	      <p>
		Finally you can define pseudo-instructions.
		An example would pseudoinstruction:
	      </p>
	      <ul>
	      <p>
	        Pseudoinstructions<br />
	        {<br />
	                li reg1=reg num=inm<br />
	                {<br />
	                       lui reg1 sel(31,16,num) ;<br />
	                       ori reg1 reg1 sel(15,0,num)<br />
	                 }<br />
	        }
	      </p>
	      <p>
	         
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322904">Figure</a> <b>15</b> <b>Example of pseudo-instruction (optional section)</b>
	      </p>
	      <p>
	        <br />
		Where the "sel (bit-start, bit-end field)" operator allows us to select a number of bits of one of the fields from the pseudo-instruction.
	      </p>
	      <p>
	         
	      </p>

      </div>


      <div id="help_assembly_format">
      <h1>Assembler in WepSIM</h1>

	      <p>
	      </p>
	      <p>
                The assembly code is described in a text file with a first data section (.data) and a second section with the code (.text)<br />
	        <br />
		In the data section it is possible to define the variables and constants that will stay in the data segment of main memory. The section begins with the <i>.data</i> directive. The directives that specify the types of data that can be defined are:
	      </p>
	      <p>
	        &middot;       <b>.ascii:</b> Is followed by a string, instructing the assembler to create a memory area with data, and store in it the indicated string.
	      </p>
	      <p>
	        &middot;       <b>.asciiz:</b> Is followed by a string, instructing the assembler to create a memory area with data, and store the associated string as a null terminated string.
	      </p>
	      <p>
	        &middot;       <b>.byte:</b> Is followed by one or more values that form part of the value of the variable. If multiple values, these values are separated by comma. The values that can be used are: <b>character, octal, hexadecimal, and decimal</b>.
	      </p>
	      <p>
	        &middot;       <b>.half:</b> Is followed by one or more values that form part of the value of the variable. If multiple values, these values are separated by comma. The values that can be used are: <b>octal, hexadecimal, and decimal</b>.
	      </p>
	      <p>
	        &middot;       <b>.word:</b> Is followed by one or more values that form part of the value of the variable. If multiple values, these values are separated by comma. The values that can be used are: <b>octal, hexadecimal, and decimal</b>.
	      </p>
	      <p>
	        &middot;       <b>.space:</b> It is followed by the number of bytes in decimal format that the user wants to allocate.
	      </p>
	      <p>
                The format of a value of the former data types is:
	      </p>
	      <p>
	        &middot;       <b>String:</b> character sequence enclosed in double quotes.<br />
	        For example: "hola 123\n"
	      </p>
	      <p>
	        &middot;       <b>Character:</b> character surrounded by simple quotes.<br />
	        For example: &apos;c&apos;.
	      </p>
	      <p>
	        &middot;       <b>Octal:</b> a number starting with zero and its digits are lower than eight. 
               For example: 012.
	      </p>
	      <p>
	        &middot;       <b>Hexadecimal:</b> a number that begins with the 0x prefix and its digits are zero through nine and the letters a, b, c, d, e, and f.<br />
	        For example: 0x12.
	      </p>
	      <p>
	        &middot;       <b>Decimal:</b> a number that is not in octal or hexadecimal, and its digits fall between zero and nine (inclusive).<br />
	        For example: 12.
	      </p>
	      <p>
		In the code section you can define subroutines staying in the code segment of main memory. The section begins with <i>.text</i> directive.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        An example program would be:
	      </p>
	      <ul>

<pre class="font-monospace">
.data
  age1:      .word 0x12345678, 20 
  alter2:    .word 20, 10 
  resultado: .word 0 
  # 32-bit word initialized with decimal
  texto:     .ascii  "Hola \t" 
  texto2:    .asciiz "Hola \t" 
  hueco:     .space 16 

.text 
.globl main 
 main: li $3 2 
       li $4 1 
       li $5 0 
</pre>

	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322908">Figure</a> <b>19</b> <b>Example of data and code sections to test microcode. </b><b><br />
	        <br /></b>
	      </p>

	      <p>
		You can use line comments using the # character.<br />
		Everything that follows this character to the end of line will be ignored by the assembler.

		There are also active comments where special tags are used to perform certain actions at runtime:
                <ul>
                <li>
		<pre class="m-0"># state:</pre>
		 Allows to save the state before executing the instruction preceding the comment.
                </li>
                <li>
		<pre class="m-0"># break:</pre>
		 Allows to set a break point during program execution.
                </li>
                <li>
		<pre class="m-0">
# notify: skip1st:true showas:offcanvas scroll2current:true
# notify: Lorem ipsum dolor sit amet, consectetur...
                </pre>
		 Allows to stop execution temporarily and display information in a side panel (offcanvas) or in a dialog box (dialogbox).
                </li>
                </ul>
	      </p>
      </div>


      <div id="help_simulator_firmware">
      <h1>Microcode management in WepSIM</h1>

	      <p>
                A text file with three sections (microcode, register naming, and definition of pseudo-instructions) is loaded in the Microcode screen. 
		Please refer to 'Microcode in WepSIM' for more information about the microcode format.
		In order to access to this screen you have to use the upper-center Microcode button (see Figure <b class="cleanuphtml-4">Figure 16</b>)
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 1" src="images/simulator/firmware001.jpg" alt="" name="Imagen 1" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Ref434190846"></a><a name="_Toc438322905"></a><a class="cleanuphtml-1" name="_Ref434190877">Figure</a> <b>16</b> <b>Main screen: option for loading microcode.</b>
	      </p>
	      <p>
	        <br />
                Then, a screen with a on-line text-editor appears where the student is able to describe the microcode (the three sections before commented). Users can load an existing microcode by using the "Load" button on the upper toolbar, modify a previously loaded microcode or save the current microcode with the "Save" button on the upper toolbar. Once the microcode is ready, click the "μcompile" button to microcompile it and load the resulting binary in the control memory, as shown in <b class="cleanuphtml-4">Figure 17</b>.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 2" src="images/simulator/firmware002.jpg" alt="" name="Imagen 2" />
	      </p>
	      <p class="MsoNormal cleanuphtml-5"></p>
	      <table cellpadding="0" cellspacing="0" align="left">
	      </table> <br clear="all" />
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322906"></a><a class="cleanuphtml-1" name="_Ref434191423">Figure</a> <b>17</b> <b>Microcode screen: text box in order to load the firmware.</b>
	      </p>
	      <p>
	        <br />
                Once the new microcode is loaded correctly, the button shown in <b class="cleanuphtml-4">Figure 18</b> let students to check the binary loaded into the control memory.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen4" src="images/simulator/firmware004.jpg" alt="Button to open the control memory modal" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="fig4"></a><a class="cleanuphtml-1" name="_Ref434191551">Figure</a> <b>18</b> <b>Microcode screen: show control memory contents.</b>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen5" src="images/simulator/firmware005.jpg" alt="Modal with the control memory content in binary" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="fig5"></a><a class="cleanuphtml-1" name="_Ref434191551">Figure</a> <b>19</b> <b>Microcode screen: binary in control memory.</b>
	      </p>
	      <p>
	        <br />
                The next step is to load the assembler program to test this microcode, and for that you have to click on the "Assembly" button on the upper toolbar.
		Please check the 'Simulator: assembly' section from help for more information.
	      </p>
	      <p>
	         
	      </p>

      </div>


      <div id="help_simulator_assembly">
      <h1>Assembler management in WepSIM</h1>

	      <p>
                A text file with two types of sections (data and code) is loaded on the Assembler screen. 
                To access to this screen the student has select the Assembly button (see <b class="cleanuphtml-3">Figure 16</b>) in the upper toolbar.
	        <br />
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="images/simulator/assembly002.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322909"></a><a class="cleanuphtml-1" name="_Toc434155501">Figure</a> <b>20</b> <b>Main screen: assembler code screen.</b>
	      </p>
	      <p>
                Then, a text editor appears where the assembly code can be loaded and edited. You can load an existing code using the "Load" button on the top bar, change a code previously loaded or save the code currently loaded with the "Save" button on the top bar.
	      </p>
	      <p>
		Once the code is ready, you have to click on the "Compile" button to compile this code into binary and to load this binary into the main memory, as shown in <b class="cleanuphtml-3">Figure 21</b>.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 28" src="images/simulator/assembly003.jpg" alt="" name="Imagen 28" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322910"></a><a class="cleanuphtml-1" name="_Ref434192102">Figure</a> <b>21</b> <b>Assembly screen: text editor for the assembly code.</b><b><br />
	        <br /></b>
	      </p>
	      <p>
                Once compiled, it will pass to the screen shown in <b class="cleanuphtml-3">Figure 22</b>, and the user can click on the button show in order to explore the content of main memory in binary (<b class="cleanuphtml-3">Figure 23</b>).
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 30" src="images/simulator/assembly004.jpg" alt="Assembly screen, button to show assembly in binary" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322912"></a><a class="cleanuphtml-1" name="_Ref434192450">Figure</a> <b>22</b> <b>Assembly screen: button to explore the main memory values.</b>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 30" src="images/simulator/assembly005.jpg" alt="Modal with the assembly in binary" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322912"></a><a class="cleanuphtml-1" name="_Ref434192450">Figure</a> <b>23</b> <b>Assembly screen: binary values.</b>
	      </p>
	      <p>
	        <br />
                The next step is to come back to the main screen in order to run the loaded microcode and assembly. 
                To do that, you have to press the "Simulator" button on the upper toolbar.
	      </p>
	      <p>
	      </p>

      </div>


      <div id="help_simulator_execution">
      <h1>Simulation in WepSIM</h1>

	      <p>
	        In the main screen it is possible to see:
	      </p>
	      <ul>
	      <li>
	        The control memory content (see <b>Figure 24</b>), with each cycle control signals.
                To do that, the student has to use the "<i>Control Memory</i>" button from the upper toolbar of the main screen.<br />
                In this tab the current cycle signals are highlighted with the blue color (and a little bit bigger font).<br />
                With the right-hand scroll bar it is possible to inspect the full control memory content.
	      </li>
	      <li>
                The main memory content (see  <b class="cleanuphtml-1">Figure 25</b>), with the assembly instruction to be executed.
                It is possible to set a breakpoint by clicking on the <i>breakpoints</i> column.
                When a breakpoint is set, a "stop" icon will appear in this column.
	      </li>
	      </ul>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 1" src="images/simulator/simulator009.jpg" alt="" name="Imagen 1" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322913"></a><a class="cleanuphtml-2" name="_Ref434192973">Figure</a> <b>24</b> <b>Main screen: visualization of the control memory.</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="images/simulator/simulator010.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322914"></a><a class="cleanuphtml-2" name="_Ref434193222">Figure</a> <b>25</b> <b>Main screen: visualization of the main memory code.</b>
	      </p>
	      <p>
	      </p>
	      <p>
                In the main screen it is possible to execute:
	      </p>
	      <p>
	        ·       Microinstruction by microinstruction by clicking on the "µInstrucci&oacute;n" button (see <b class="cleanuphtml-1">Figure 26</b>), to move forward to the next clock cycle, and to send the associated control signals.
	      </p>
	      <p>
	        ·       Instruction by instruction by clicking on the "Instrucci&oacute;n" button (see <b class="cleanuphtml-1">Figure 26</b>) in order to generate all clock cycles for the microcode of the corresponding instruction, stopping at the beginning of the fetch.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 4" src="images/simulator/simulator011.jpg" alt="" name="Imagen 4" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322915"></a><a class="cleanuphtml-2" name="_Ref434193775">Figure</a> <b>26</b> <b>Main screen: execution options.</b>
	      </p>
	      <p>
	        <br />
	        With the "<i>Registers</i>" button on the upper-right bar of the main screen (see <b class="cleanuphtml-1">Figure 26</b>) it is possible to see the values of the processor registers, and how them change during the execution.
	      </p>
	      <p>
                It is also possible to see the control unit, as is shown in <b class="cleanuphtml-1">Figure 27</b>.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 8" src="images/simulator/simulator012.jpg" alt="" name="Imagen 8" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322916"></a><a class="cleanuphtml-2" name="_Ref434194139">Figure</a> <b>27</b> <b>Main screen: control unit visualization.</b>
	      </p>
	      <p>
                And it is also possible to reset the execution by clicking on the "Reset" button in the top bar.
	      </p>
	      <p>
	      </p>
	      <p>
	      </p>

      </div>


      <div id="help_checker">

              It is possible to check that the current state fulfill our requirements:
	      <p>
	      <ul>
	        <li>To check the current state, please introduce requirements and press "check".</li>
	        <c>
	        For example:<br>
	        <textarea aria-label="checks to perform" rows="2">
register 5 >= 8 ; memory 1 = 0x10; screen 0 == first_line
	        </textarea>
	        </c>
	        <li>To clean the requirements, press "clean".</li>
	      </ul>
	      <p>
	      <b>TIP: the semicolons are needed.</b>
	      <br>
	      <b>TIP: please be careful because the scroll bars use to be hidden.</b>
	      <br>
	      When empty requirements are provided, the initial state is taken into consideration.

      </div>


      <div id="help_dumper">

	      <ul>
	      <li>
              The 'Current state' panel by default shows the state of the simulated machine (at assembly level) at the present moment.
	      The machine state is the list of elements in the hardware and its values. 
	      In order to simplify, only the non-zero values hardware elements are shown. <br>
	      For example:<br>
	        <textarea aria-label="checks to perform" rows="2" class="w-50">
register 5 >= 8 ; memory 1 = 0x10; screen 0 == first_line
	        </textarea>
	      <br>
              Please, remember two important details:
	      <ul>
	        <li><em>The semicolons are needed.</em> 
                     The ';' character indicates the end of any key=value pair.</li>
	        <li><em>The scroll bars use to be hidden on current-state and differencies.</em></li>
	      </ul>

	      This 'Current state' can be modified, copy to the clipboard or stored in the 'History' panel.
	      <li>
              The 'History' panel allows users to keep track of the state at different CPU clock cycles.
	      <li>
              The 'Difference' panel can be used to show the differences between two states.
	      Only the values that are different between two states are shown.
	      </ul>

	      <p>
	      <ul>
              The typical steps for using this dialog box are shown in this animation:<br>
	      <img class="w-75" src="images/welcome/states_usage.gif">
	      </ul>

      </div>

  </body>
</html>
